using MemoryEventBus.Domain.Events.Aggregate;
using MemoryEventBus.Domain.Events.Interfaces.Base;
using Microsoft.Extensions.Logging;

namespace MemoryEventBus.Infrastructure.Events.ErrorHandling
{
    public class DefaultEventBusErrorHandler : IEventBusErrorHandler
    {
        private readonly ILogger<DefaultEventBusErrorHandler> _logger;
        private readonly Dictionary<Type, int> _maxRetryAttempts;

        public DefaultEventBusErrorHandler(ILogger<DefaultEventBusErrorHandler> logger)
        {
            _logger = logger;
            _maxRetryAttempts = new Dictionary<Type, int>
            {
                { typeof(DomainEvent), 3 } // Default retry attempts
            };
        }

        public async Task HandleErrorAsync<TEvent>(TEvent @event, Exception exception, int attemptNumber, CancellationToken cancellationToken = default) 
            where TEvent : DomainEvent
        {
            _logger.LogError(exception, 
                "Error processing event {EventType} with ID {EventId} on attempt {AttemptNumber}. Error: {ErrorMessage}",
                typeof(TEvent).Name, @event.EventId, attemptNumber, exception.Message);

            // Add metrics here if needed
            await Task.CompletedTask;
        }

        public bool ShouldRetry<TEvent>(TEvent @event, Exception exception, int attemptNumber) 
            where TEvent : DomainEvent
        {
            var maxAttempts = _maxRetryAttempts.GetValueOrDefault(typeof(TEvent), 3);
            
            // Don't retry for certain exception types
            if (exception is ArgumentException or InvalidOperationException)
                return false;

            return attemptNumber < maxAttempts;
        }

        public void SetMaxRetryAttempts<TEvent>(int maxAttempts) where TEvent : DomainEvent
        {
            _maxRetryAttempts[typeof(TEvent)] = maxAttempts;
        }
    }
}