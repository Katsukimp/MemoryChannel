using MemoryEventBus.Domain.Events.Concrete;
using MemoryEventBus.Domain.Events.Interfaces.Base;
using MemoryEventBus.Infrastructure.Events.Consumers.Base;
using Microsoft.Extensions.Logging;

namespace MemoryEventBus.Infrastructure.Events.Consumers
{
    public class StockReducerConsumer : BaseEventConsumer<OrderPaidEvent>
    {
        public StockReducerConsumer(
            IEventChannelManager channelManager,
            ILogger<BaseEventConsumer<OrderPaidEvent>> logger,
            IEventBusErrorHandler errorHandler,
            IRetryPolicy retryPolicy,
            IEventBusMetrics? metrics = null) 
            : base(channelManager, logger, errorHandler, retryPolicy, metrics)
        {
        }

        protected override async Task ProcessEventAsync(OrderPaidEvent @event, CancellationToken cancellationToken)
        {
            // Simulate some processing work
            await Task.Delay(100, cancellationToken);
            
            // Simulate occasional failures for testing retry logic
            if (Random.Shared.Next(1, 10) <= 2) // 20% failure rate for testing
            {
                throw new InvalidOperationException("Simulated processing error");
            }

            Console.WriteLine($"Successfully processed OrderPaidEvent: {@event.EventName} | {@event.EventId} | Order Amount: {@event.Message.TotalAmount}");
        }
    }
}
