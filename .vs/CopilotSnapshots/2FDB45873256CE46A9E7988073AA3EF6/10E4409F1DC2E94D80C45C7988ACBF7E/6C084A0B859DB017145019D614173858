using MemoryEventBus.Domain.Events.Aggregate;
using MemoryEventBus.Domain.Events.Concrete;
using MemoryEventBus.Domain.Events.Interfaces.Base;
using Microsoft.Extensions.Hosting;
using System.Threading.Channels;

namespace MemoryEventBus.Infrastructure.Events.Consumers
{
    public class StockReducerConsumer : BackgroundService
    {
        private readonly Channel<DomainEvent> _channel;

        public StockReducerConsumer(IEventChannelManager channelManager)
        {
            _channel = channelManager.GetOrCreateChannel<OrderPaidEvent>();
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            await foreach (var domainEvent in _channel.Reader.ReadAllAsync(stoppingToken))
            {
                if (domainEvent is OrderPaidEvent orderPaidEvent)
                {
                    await ProcessEventAsync(orderPaidEvent, stoppingToken);
                }
            }
        }

        private async Task ProcessEventAsync(OrderPaidEvent @event, CancellationToken cancellationToken)
        {
            try
            {
                // Simulate some processing work
                await Task.Delay(100, cancellationToken);
                
                Console.WriteLine($"Successfully processed OrderPaidEvent: {@event.EventName} | {@event.EventId} | Order Amount: {@event.Message.TotalAmount}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error processing OrderPaidEvent {@event.EventId}: {ex.Message}");
                // In a real scenario, you'd implement retry logic here
            }
        }
    }
}
